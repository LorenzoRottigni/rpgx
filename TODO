- git submodules to create repos:
    rpgx/core	Rust core crates (lib, engine, etc.)
    rpgx/js	JS driver package
    rpgx/vue	Vue driver plugin
    rpgx/wasm	Wasm driver
    rpgx/playground-vue	Vue playground frontend
    rpgx/playground-node	Node playground
    rpgx/monorepo   Wrapper repo with Makefile package.json and cargo.json workspaces
- Make entities ID unique and consistent, recompute them at each mutation
- Make errors management consistent
- Manage traits to unify functionalities
- Check all stacks datatypes i32,...
- Convert Effect to an enum:
    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
    pub enum Effect {
        Texture(i32),
        Action(i32),
        Render(i32),
        Block(bool),
        Group(bool),
        Shrink(BlockSelector),
    }
  And manage it on the Tile sticking to the stack: pub effects: [Effect; EFFECTS_LENGTH]

------------------------------------------------------


- Create and manage Tile.data, Mask should contain the data on the heap and distribute to its generated tile the reference to that data.
  Since Mask isn't used at runtime it can go on the heap so the tile can put on the stack the reference to the mask heap data.

    Using lifetimes should be possible to:
        - add a box into Mask
        - add the reference to the Mask box to the Tile
        - explicit lifetime throught layer, mask, tile to satisify the rust compiler

- MAYBE it's a good deal to directly put a Mask reference into the tile.
  Following the pointer to the mask allows me to retrieve effects and more from the mask, deduplicating data. So the Mask.apply has just to associated the mask itself to target tiles!

- if Mask outlives Layer than i can put Mask reference in layer tiles.

- Layer might directly take tiles (with mask referenced) as input.